\section{Hyperledger Fabric}
	\hspace{10mm}Hyperledger Fabric (or Fabric for short) is, at its core, a private, permissioned Blockchain technology. This Blockchain technology goes under the differential term of Distributed Ledger Technology to (a) stay in line with the more "enterprise-like" Use Cases for which certain organizations will turn to it, and (b) stand out from other Blockchain technologies like that of Bitcoin and Ethereum. An extended reason is that there is no underlying cryptocurrency for this network (unlike systems like Bitcoin and Ethereum).\footnote{Although, one COULD actually implement a cryptocurrency on the Fabric system if one was so inclined. However, it would never be as necessary as it would for the public blockchains.} And unlike those open, permissionless offerings where nodes are typically anonymous, Fabric uses X.509 certificates to establish identities on its network. The reasons for this are many-fold, but two of the biggest that necessitate identities are that identities are the way that Fabric can maintain its "permissioned" nature as well as to stay in line with certain regulations and best practices to which a business would have to adhere.\\
	
	\hspace{10mm}Along with this difference, Fabric also employs a \textit{deterministic} consensus algorithm whereas the open offerings use \textit{probabilistic} versions. This makes sense since the whole reason for a probabilistic consensus algorithm is to make sure that no one node (or group of nodes) can take control of the network keeping something like Bitcoin ruled by all. In comparison, a Fabric network \textit{knows} all of its participants and would not need to have to keep the control open to all, and in fact routinely elects leaders under its Raft Consensus Protocol. More on Raft later in this section. The advantage of a deterministic consensus algorithm is to keep the transaction throughput performance high while making sure that confirmations latency of the transactions is kept low.\\
	
	\hspace{10mm}This section is dedicated to going over the different elements of what makes the Fabric Network function, why those elements exist, and how they all come together to provide a enterprise-grade Blockchain system, which is also known by its more business-like name of Distributed Ledger Technology. The Use Cases go well outside that of the security network for which this project is using it, and they include the fields of Healthcare, Supply-Chain, Education, and more! The next few subsections will go over the components of the Fabric system in a logical progression from the view of setting up the network as an administrator.\\
		
	\subsection{The Certificate Authority Servers}
		\hspace{10mm}The Certificate Authority (CA) Servers of the Fabric System are a logical place to start as they are the first thing to get administered in a production environment. As mention above, nodes on the Fabric network all have identities associated with them. This is what enforces the \textit{permissioned} quality of the system. These identities come in the form a X.509 certificates. The certificates are created and issued by a couple of CA Servers\footnote{While the Fabric system allows for the use of Intermediate CA Servers, my project won't be using them so they won't be mentioned in this report.}: The Transport Layer Security (TLS) CA Server and the Organizational (Fabric) CA Server.\\
		
		\hspace{10mm}The TLS CA Server is the one that secures communications of the different nodes using, surprisingly, the Transport Layer Security (TLS) Protocol. This protocol is the same one which protects most encrypted communications on the internet. For example, in the realm of Web traffic, it is the 's' in 'https'. All nodes on the network need to have a certificate provided by the TLS Server to be able to communicate. Each Organization that wishes to participate on the network should have one to dole out these certificates. As such, in my project all three organizations will have their own TLS Servers. These servers are relatively straight forward in the purpose and not the more interesting of the two.\\
		
		\hspace{10mm}The more interesting of the two CA Servers is the Organizational (Fabric) Server. A quick comment on why I'm using both of the terms "Organizational" and "Fabric" here: the Hyperledger Fabric Guides refer to the server as the Organizational Server to differentiate it from the TLS Server. However, I find the term "Organizational" lacking, or more specifically overloaded, as this term is used often when talking in relation to the other aspects of the participating Organization. For this reason, I opted to use the term "Fabric CA" when talking about this CA. The word "Fabric" is, of course, itself an overloaded term in these guides as well, but far less in my estimation than that of "Organizational". That being said, moving forward, I will just be using the term "Fabric" or "Fab" CA Server to refer to this entity.\\
		
		\hspace{10mm}The Fabric CA Server is the server that manages the identities on the network as they are recognized by the Fabric Network. There are four types of Identities: admin, client, peer, and orderer. These are encoded into the certificates that an entity will get and used in the Fabric network with a special element called a NodeOU. NodeOUs (Node Organizational Units) are an artifact of the Fabric system and are not to be confused with the general Organizational Units of an X.509 certificate. It should be mentioned that there is technically a fifth identity type which is "none" or the absence of a NodeOU, more accurately. These aren't really used by anything other than the CA Servers themselves. Notice I said "that an entity will get" and not "that a node will get", that is because only two of those are used for nodes, specifically the peer and orderer. The other two are used for entities that act as administrators for either a given node or an organization and the end clients that will eventually be using the system. \\
		
		\hspace{10mm}The administering of a CA Server in Fabric is done through the \textit{fabric-ca-server-config.yaml} file. This is explained in much greater detail in the scripts section. When a CA Server is bootstrapped, it creates one of these files to be edited, and then it is consumed when the server is launched. \\
		
		\hspace{10mm}So, the main purpose of the CA Servers are to serve cryptographic material in the form of certificates and secret keys. Of course, with every actor on the network needing an identity, Certificate Management is paramount, and Fabric has a solution to this: certificate management and enforcement is done via a construct called Membership Service Providers (MSPs).\\
		
	\subsection{Membership Service Providers}
		\hspace{10mm}Membership Service Providers (MSPs), unlike their name suggests, don't \textit{actually} provide anything and instead are a well-defined way for a Fabric network to manage and consume identities. A lot of elements of the Fabric network need to know identities to make sure everything is correct with regard to its distributed nature from Endorsing Peers to Orderer Signing to Administrator Management and more. To not get lost in the certificate nightmare one might imagine this to be, MSPs hold that cryptographic material. Even though I have only been mentioning certificates up until now, there are host of different crypto objects that the MSP holds such as the signing key and the root TLS CA certificate. This is an example of a MSP listing for the Orderer Organization of my project:
		
		\verbatiminput{./fabsec-report-hyperledger/msp-tree-nonuni.txt}
		
		\hspace{10mm}While each MSP may hold different material, their structure is pretty standard. Harkening back to the topic of CAs, the Fabric CA is responsible for generating and delivering these MSPs upon a successful enrollment command. There are informally two type of MSPs: Channel MSPs which belong to the Organizations that are to administer and participate in a given Channel (more on those below) and the Local MSPs which define what role the entity to whom that MSP belongs to will play. Let's take a look into two of the big type of entities now: Peers and Orderers.\\
		
	\subsection{Peers}
		\hspace{10mm}A Peer Node is the node that contains, or hosts, the Ledgers and the Chaincode. More specifically they host \textit{instances} of the Ledgers and Chaincode, with which the end user will eventually interact with, as every peer within a Channel will host their own copy. This is another way the decentralized nature of this system shows itself as well as a way it supports the CIA triad's Availability tenet. Peers are the main mechanism by which clients, usually applications, and administrators interact with the Ledger through calls to their Chaincode. All peers are \textit{Committing Peers} meaning they receive endorsed blocks and commit them to the blockchain. A certain subset of these peers, however, are also called \textit{Endorsing Peers} and they will endorse the transactions, which is done by the act of signing transactions with their private key after checking the transaction's correctness, which will then get sent to an Orderer Node by the Client.\\	
		
	\subsection{Orderers}
		\hspace{10mm}An Orderer Node is the node that collects the different transactions and \textit{orderers} them into the blocks that will eventually go on the ledger, i.e. the blockchain. In a public blockchain system, every node has the chance to be "an orderer" so-to-speak however they call them Miners. While this isn't a paper on those types of systems, it is important to understand that that is another thing Fabric (and I'm sure other permissioned blockchain solutions) does: separates the role of the Peer from that of an Orderer (Miner) -- whereas every node in a public blockchain has the potential to have all of the functionality of a Peer and Orderer (Miner).\\
		
		\hspace{10mm}Fabric doesn't need "miners" since their consensus protocol is not based on any form of cryptographic mining. The main reason for this is the act of cryptographic mining is used to make sure the any node has a chance to propose blocks for the chain ensuring that no one node, or group of nodes, has control over the network and thus preserving its decentralized nature in a trustless environment. Fabric doesn't have the problem of a \textit{trustless environment} to overcome. Every node has a known identity from a known parent organization.\\
		
		\hspace{10mm}So, Fabric has separated these roles of Peers -- which talk to clients, execute Chaincode, and endorse transactions -- from Orderers -- which order the transactions into blocks and distributes those blocks to the Peers. An important thing to note is that an Orderer doesn't actually validate any of the transactions that they package into blocks as that is done by the Peers. They instead enforce the access controls in two ways. One, they maintain a list of Organizations that are participating in the Consortium. And two, they control the read/write access of a given Channel for which they are an Orderer. (More on Channels and how Orderer get these policies in the Channel section).\\
		
		\hspace{10mm}Finally, the Orderers actually have a choice of  consensus protocols from which to choose. Now, granted this project only has one Orderer, so it doesn't have to actually reach consensus with any other node than itself. However even for an orderer of one, a Fabric network architect still has to choose, set-up, and maintain one of the consensus protocols. And further, Fabric is designed in such a way that orderers can be added and removed from the Ordering Service\footnote{A group of Orderers is known as an Ordering Service.} at any time meaning that the consensus protocol is just as important to an Ordering Service of one as it is to an Ordering Service of five. The one that is the default, and as of version 2.0 of Fabric the recommended, choice is that of Raft. So this is the protocol I will be going with.\\
		
		\subsubsection{The Raft Consensus Protocol}
			\hspace{10mm}The Raft Consensus Protocol is an embedded, Crash-Fault Tolerated protocol which is used to solve the Byzantine General's problem of consensus. That is, how does one have all nodes agree on a value for a given transaction. It uses a model in which a leader is elected among the set of orderers based on random time intervals. The Leader Election process is rather interesting and is certainly lend itself well to the scalability of future endeavors involving many more nodes. However, having an Ordering Service of one, there will only be one leader. This means that a lot of the Consensus process involving broadcasting accepted entries and committing them won't be happening on my network. Because of this, it is useful to mention, but I won't be going into depth on it. However, it will peak its head out again in the scripts section.\\
			
	\subsection{Channels}
		\hspace{10mm} Channels are the main way that nodes associate themselves with not only other nodes, but with the Ledgers and Chaincode as well. They act rather similarly to a subnet keeping communications confidential for only those within a channel. As such, it is how an Orderer can do its job of access control. Each node can belong to multiple Channels which gives Fabric is claim to "multi-tenancy" fame. In fact, with my conception of how you would have Fabric be a security network, each of the Use Cases I mentioned (PKI, DDoS protection, etc.) would use their own Channel. This is a natural way to logically separate concerns. Since PKI management is not reliant on DDoS protection and vice versa, one shouldn't have them logically muddled on the same (sub)network.\\
		
		\hspace{10mm}Another quick note to point out: a Channel is governed by a configuration file called \textit{configtx.yaml}. This paper goes much more in-depth to what this file is and how it is used later in the \textit{Scripts} section, but one of its main purposes is to be consumed by a program called the \textit{configtxgen} which then uses it to create a special block for the Blockchain that holds this configuration data called The Genesis Block.\\
		
		\subsubsection{The Genesis Block}
			\hspace{10mm}The Genesis Block is a very important element of the Fabric network. As its name suggests, it is the first block on any given Blockchain on the network, and it is needed to \textit{bootstrap} the first Orderer of an Ordering Service. It hosts the configuration data that governs the given Ledger that it is the first block for. This is a reflection of the Genesis Block of a public blockchain network which is needed for, among other things, the "previous hash" for the next block in the chain.\\
			
	\subsection{Ledgers}
		\hspace{10mm}Ledgers are immutable data structures that contain all the transactions generated by the Chaincode for a certain Blockchain. They encapsulate the \textit{shared information} of a Fabric network. A single Ledger can be thought of as two components: a World State and the Blockchain itself. The World State is the state of things (e.g. the values, transactions, etc.) after the last accepted block. This is mostly for metadata and efficiency purposes so these values don't need to be calculated every time. Of course, that leaves the blockchain which should be plenty familiar by now. Note: the values in the blockchain are not accessed directly, but are instead accessed through the programmable logic of Chaincode.\\
				
	\subsection{Chaincode}
		\hspace{10mm}Chaincode, as mentioned briefly before, is the Hyperledger equivalent to Smart Contracts. These are Turing-complete programs that hold the business logic for a given Use Case, such as the logging aggregator logic of this project. In that spirit, they are used to encapsulate the \textit{shared processes} of the Fabric Network. There are two types of Chaincode: System Chaincode and Application Chaincode. The System Chaincode holds the logic for things like querying the ledger and how Peers will endorse transactions. The Application Chaincode is what a Fabric developer will end up creating, and this project's Application Chaincode is discussed in detail further into this report.\\
