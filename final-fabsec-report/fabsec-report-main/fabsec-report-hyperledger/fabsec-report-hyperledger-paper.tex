\section{Hyperledger Fabric}
	\hspace{10mm}Hyperledger Fabric (or Fabric for short) is, at its core, a private, permissioned Blockchain technology. This Blockchain technology goes under a the differential term of Distributed Ledger Technology to (a) stay in line with the more "enterprise-like" Use Cases for which certain organizations will turn to it, and (b) stand out from other Blockchain technologies like that of Bitcoin and Ethereum. Unlike those open, permissionless offerings where nodes are typically anonymous, Fabric uses X.509 certificates to establish identities on its network. The reasons for this are many-fold, but two of the biggest that necessitate identities are that identities are the way that Fabric can maintain its "permissioned" nature as well as to stay in line with certain regulations and best practices to which a business would have to adhere. Along with this difference, Fabric also employs a \textit{deterministic} consensus algorithm whereas the open offerings use \textit{probabilistic} versions. This makes sense since the whole reason for a probabilistic consensus algorithm is to make sure that no one node (or group of nodes) can take control of the network keeping something like Bitcoin ruled by all. In comparison, a Fabric network \textit{knows} all of its participants and would not need to have to keep the control open to all, and in fact routinely elects leaders under its Raft Consensus Protocol. More on Raft later in this section. The advantage of a deterministic consensus algorithm is to keep the transaction throughput performance high while making sure that confirmations latency of the transactions is kept low.\\
	
	\hspace{10mm}This section is dedicated to going over the different elements of what makes the Fabric Network work, why those elements exist, and how they all come together to provide a enterprise-grade Blockchain system, and also known by its more business-like name of Distributed Ledger Technology, whose Use Cases go well outside that of the Security Network that this project is using it for and include the fields of Healthcare, Supply-Chain, Education, and more!\\
		
	\subsection{The Certificate Authority Servers}
		\hspace{10mm}The Certificate Authority (CA) Servers of the Fabric System are a logical place to start as they are the first thing to get administered in a production environment. As mention above, nodes on the Fabric network all have identities associated with them. This is what enforces the \textit{permissioned} quality of the system. These identities come in the form a X.509 certificates. The certificates are created and issued by a couple of CA Servers\footnote{While the Fabric system allows for the use of Intermediate CA Servers, my project won't be using them so they won't be mentioned in this report.}: The Transport Layer Security (TLS) CA Server and the Organizational (Fabric) CA Server.\\
		
		\hspace{10mm}The TLS CA Server is the one that secures communications of the different nodes using, surprisingly, the Transport Layer Security (TLS) Protocol. This protocol is the same one which protects most encrypted communications on the internet. For example, in the realm of Web traffic, it is the 's' in 'https'. All nodes on the network need to have a certificate provided by the TLS Server to be able to communicate. Each Organization that wishes to participate on the network should have one to dole out these certificates. As such, in my project all three organizations will have their own TLS Servers. These servers are relatively straight forward in the purpose and not the more interesting of the two.\\
		
		\hspace{10mm}The more interesting of the two CA Servers is the Organizational (Fabric) Server. A quick comment on why I'm using "Organizational" and "Fabric" here: the Hyperledger Fabric Guides refer to the server as the Organizational Server to differentiate it from the TLS Server. However, I find the term "Organizational" lacking (read: overloaded) as this term is used often when talking in relation to the other aspects of the participating Organizations. For this reason, I opted to use the term "Fabric CA" when talking about this CA. The word "Fabric" is, of course, itself an overloaded term in these guides as well, but far less in my estimation than that of "Organizational". That being said, moving forward, I will just be using the term "Fabric" or "Fab" CA Server to refer to this entity.\\
		
		\hspace{10mm}The Fabric CA Server is the server that manages the identities on the network as they are recognized by the Fabric Network. There are four types of Identities: admin, client, peer, and orderer. These are encoded into the certificates that an entity will get and used in the Fabric network with a special element called a NodeOU. NodeOUs (Node Organizational Units) are an artifact of the Fabric system and are not to be confused with the general Organizational Units of an X.509 certificate. This is technically a fifth identity type which is "none" or the absence of a NodeOU more accurately. These aren't really used by anything other than the CA Servers themselves. Notice I said "that an entity will get" and not "that a node will get", that is because only two of those are used for nodes, specifically the peer and orderer. The other two are used for entities that act as administrators for either a given node or an organization and the end clients that will eventually be using the system. \\
		
		\hspace{10mm}The administering of a CA Server in Fabric is done through the \textit{fabric-ca-server-config.yaml} file. This is explained in much greater detail in the scripts section. When a CA Server is bootstrapped, it creates one of these files to be edited, and then it is consumed when the Server is launched. \\
		
		\hspace{10mm}So, the main purpose of the CA Servers are to serve cryptographic material in the form of certificates and secret keys. Of course, with even actor on the network needing an identity, Certificate Management is paramount, and Fabric has a solution to this: certificate management and enforcement is done via a construct called Membership Service Providers (MSPs).\\
		
	\subsection{Membership Service Providers}
		\hspace{10mm}Membership Service Providers (MSPs), unlike their name suggests, don't \textit{actually} provide anything and instead are a well-defined way for a Fabric network to manage and consume an identity. A lot of elements of the Fabric network need to know identities to make sure everything is correct with regard to its distributed nature from Endorsing Peers to Orderer Signing to Administrator Management and more. To not get lost in the certificate nightmare one might imagine this to be, MSPs hold that cryptographic material. Every though I have only been mentioning certificates up until now, there are host of different crypto objects that the MSP holds such as the signing key and the root TLS CA certificate. This is an example of a MSP listing for the Orderer Organization of my project:
		
		\verbatiminput{./fabsec-report-hyperledger/msp-tree-nonuni.txt}
		
		\hspace{10mm}While each MSP may hold different material, their structure is pretty standard. Harkening back to the topic of CAs, the Fabric CA is responsible for generating and delivering these MSPs upon a successful enrollment command. There are informally two type of MSPs: Channel MSPs which belong to the Organizations that are to administer and participate in a given Channel (more on those below) and the Local MSPs which define what role the entity to whom that MSP belongs to will play. Let's take a look into two of the big type of entities now: Peers and Orderers.\\
		
	\subsection{Peers}
		\hspace{10mm}A Peer Node is the node that contains, or hosts, the Ledgers and the Chaincode. More specifically they host \textit{instances} of the Ledgers and Chaincode as every peer within a Channel will host their own copy. This is another way the decentralized nature of this system shows itself. Peers are the main mechanism by which clients, usually applications, and administrators interact with the Ledger through calls to their Chaincode. They will also endorse transactions, which is done by the act of signing transactions with their private key, that will then get sent to an Orderer Node.\\	
		
	\subsection{Orderers}
		\hspace{10mm}An Orderer Node is the node that collects the different transactions and \textit{orderers} them into the blocks that will eventually go on the ledger, i.e. the blockchain. In a public blockchain system, every node has the chance to be "an orderer" so-to-speak however they call them Miners. While this isn't a paper on those types of systems, it is important to understand that that is another thing Fabric (and I'm sure other permissioned blockchain solutions) does: separates the role of the Peer from an Orderer (Miner) -- whereas every node in a public blockchain has the potential to have all of the functional of a Peer and Orderer (Miner).\\
		
		\hspace{10mm}Fabric doesn't need "miners" since their consensus protocol is not based on any form of cryptographic mining. The main reason for this is the act of cryptographic mining is used to make sure the any node has a chance to propose blocks for the chain ensuring that no one node, or group of nodes, has control over the network and thus preserving its decentralized nature in a trustless environment. Fabric doesn't have the problem of a \textit{trustless environment} to overcome. Every node has a known identity and a known parent organization.\\
		
		\hspace{10mm}So, Fabric has separated these roles of Peers -- which talk to clients, execute Chaincode, and endorse transactions -- from Orderers -- which order the transactions into blocks and distributes those blocks to the Peers. An important thing to note is that an Orderer doesn't actually validate any of the transactions that they package into blocks as that is done by the Peers. They instead enforce the access controls in two ways. One, they maintain a list of Organizations that are participating in the Consortium. And two, they control the read/write access of a given Channel for which they are an Orderer. (More on Channels and how Orderer get these policies in the Channel section.)\\
		
		\hspace{10mm}Finally, the Orderers actually have a choice of  consensus protocols from which to choose. Now, granted my project only has one Orderer, so it doesn't have to actually reach consensus with any other node than itself. However even for an Orderer of one, a Fabric network architect still has to choose, set-up, and maintain one of the consensus protocols. And further, Fabric is designed in such a way the Orderers can be added and removed from the Ordering Service\footnote{A group of Orderers is known as an Ordering Service.} at any time meaning that the consensus protocol is just as important to an Ordering Service of one as it is to an Ordering Service of five. The one that is the default, and as of version 2.0 of Fabric the recommended, choice is that of Raft. So this is the protocol I will be going with.\\
		
		\subsubsection{The Raft Consensus Protocol}
			\hspace{10mm}The Raft Consensus Protocol is an embedded, Crash-Fault Tolerated protocol. It uses a model in which a leader is elected among the set of Orderers based on random time intervals. The Leader Election process is rather interesting and is certainly useful for future endeavors. However, having an Ordering Service of one, there will be one leader. This means that a lot of the Consensus process involving broadcasting accepted entries and committing them won't be happening on my network. Because of this, it is useful to mention, but I won't be going into depth on it. However, it will peak its head out again in the scripts section.\\
			
	\subsection{Channels}
		\hspace{10mm} Channels are the main way that nodes associate themselves with not only other nodes, but with the Ledgers and Chaincode as well. They act rather similarly to a subnet keeping communications confidential for only those within a channel. As such, it is how an Orderer can do its job of access control. Each node can belong to multiple Channels which gives Fabric is claim to "multi-tenancy" fame. In fact, with my conception of how you would have Fabric be a security network, each of the Use Cases I mentioned PKI, DDoS protection, etc. would use their own Channel. This is a nice way to logically separate concerns since PKI management is not reliant on DDoS protection and vice versa, so why have them logically muddled on the same (sub)network? You shouldn't!\\
		
		\hspace{10mm}A Channel is govern by a configuration for call \textit{configtx.yaml}. Again, this paper goes much more in-depth to what this file is and how it is used in the Scripts section, but one of its main uses it to be consumed by a binary called the \textit{configtxgen} which uses it to create a special block for the Blockchain that hold this configuration data called The Genesis Block.\\
		
		\subsubsection{The Genesis Block}
			\hspace{10mm}The Genesis Block is a very important element of the Fabric network. As its name suggests, it is the first block on any given Blockchain on the network, and it is needed to \textit{bootstrap} the first Orderer of an Ordering Service. It hosts the configuration data the governs the given Ledger that it is the first block for.\\
			
	\subsection{Ledgers}
		\hspace{10mm}Ledgers are immutables of all the transactions generated by the Chaincode. They encapsulate the \textit{shared information} in a Fabric network. They are not accessed directly, but are instead accessed through the programmable logic of Chaincode.\\
				
	\subsection{Chaincode}
		\hspace{10mm}Chaincode, as mentioned briefly before, is the Hyperledger equivalent to Smart Contracts. These are Turing-complete programs that hold the business logic for a given Use Case, such as the logging aggregator logic of this project. In that spirit, they are used to encapsulate the \textit{shared processes} of the Fabric Network.\\
